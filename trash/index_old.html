<html>

<head>
    <meta charset=utf-8>
    <title>My first Three.js app</title>
    <style>
        body {
            margin: 0;
            background-color: #000000;
        }
        
        canvas {
            position: absolute;
            top: 100px;
            width: 100%;
            height: 100%
        }
    </style>

</head>

<body>

    <div id='gameTask' style="position: absolute; text-align: center; width: 0px; height: 0px;  font-size: 0px; color: white; top: 0px; left: 0px;">
        Find
    </div>

    <div id='gameTimer' style="position: absolute; text-align: center; width: 0px; height: 0px; font-size: 0px; color: white; top: 0px; left: 0px;">
        Time
    </div>

    <div id='gameRoundInfo' style="position: absolute; text-align: left; width: 0px; height: 0px;  font-size: 0px; color: white; top: 0px; left: 0px;">
        Round
    </div>

    <div id='gameScoreInfo' style="position: absolute; text-align: right; width: 0px; height: 0px;  font-size: 0px; color: white; top: 0px; left: 0px;">
        Round
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.js"></script>
    <script>
        var sceneSize = {
            x: 1920,
            y: 730,
            ratio: 0.0
        }
        sceneSize.ratio = sceneSize.x / sceneSize.y;
        var rendererSize = {
            x: window.innerWidth,
            y: window.innerWidth / sceneSize.ratio
        }
        var scene = new THREE.Scene();
        //~ var camera = new THREE.OrthographicCamera( window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 0, 1000);
        var camera = new THREE.OrthographicCamera(sceneSize.x / -2, sceneSize.x / 2, sceneSize.y / 2, sceneSize.y / -2,
            0, 1000); // everything closer than the near clipping/further than far clipping isn't gonna be displayed
        var gameTask = document.getElementById('gameTask');
        var gameTimer = document.getElementById('gameTimer');
        var gameRoundInfo = document.getElementById('gameRoundInfo');
        var gameScoreInfo = document.getElementById('gameScoreInfo');
        var roundTime;
        var gameScore = 0;
        var currentRound = 0;
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(rendererSize.x, rendererSize.y);
        document.body.appendChild(renderer.domElement);
        document.addEventListener('click', getMousePosition);
        var material = new THREE.MeshBasicMaterial({
            color: 0xff0000
        });
        var circleGeometry = new THREE.CircleGeometry(50, 30);
        var Circle = new THREE.Mesh(circleGeometry, material);
        var triangleGeometry = new THREE.CircleGeometry(60, 3);
        var Triangle = new THREE.Mesh(triangleGeometry, material);
        var squareGeometry = new THREE.Geometry();
        squareGeometry.vertices.push(new THREE.Vector3(-50, -50, 0));
        squareGeometry.vertices.push(new THREE.Vector3(-50, 50, 0));
        squareGeometry.vertices.push(new THREE.Vector3(50, 50, 0));
        squareGeometry.vertices.push(new THREE.Vector3(50, -50, 0));
        squareGeometry.faces.push(new THREE.Face3(0, 3, 2));
        squareGeometry.faces.push(new THREE.Face3(0, 2, 1));
        var Square = new THREE.Mesh(squareGeometry, material);
        var rhombusGeometry = new THREE.Geometry();
        rhombusGeometry.vertices.push(new THREE.Vector3(0, -70, 0));
        rhombusGeometry.vertices.push(new THREE.Vector3(-40, 0, 0));
        rhombusGeometry.vertices.push(new THREE.Vector3(0, 70, 0));
        rhombusGeometry.vertices.push(new THREE.Vector3(40, 0, 0));
        rhombusGeometry.faces.push(new THREE.Face3(0, 3, 2));
        rhombusGeometry.faces.push(new THREE.Face3(0, 2, 1));
        var Rhombus = new THREE.Mesh(rhombusGeometry, material);
        var figureForms = [
            'square',
            'circle',
            'triangle',
            'rhombus'
        ];
        var figureColors = [
            'red',
            'green',
            'white',
            'blue',
            'yellow',
            'cyan'
        ];
        var matherials = [
            new THREE.MeshBasicMaterial({
                color: 0xff0000
            }),
            new THREE.MeshBasicMaterial({
                color: 0x00ff00
            }),
            new THREE.MeshBasicMaterial({
                color: 0xffffff
            }),
            new THREE.MeshBasicMaterial({
                color: 0x0000ff
            }),
            new THREE.MeshBasicMaterial({
                color: 0xffff00
            }),
            new THREE.MeshBasicMaterial({
                color: 0x00ffff
            })
        ]
        var figureMovement = [
            'motionless',
            'jumping',
            'flying',
            'rotating'
        ];
        var numFigures = 24;
        var figures = [];
        var taskSet = [];
        generateTaskSet();
        for (var i = 0; i < numFigures; i++) {
            figures[i] = {
                x: 0.0,
                y: 0.0,
                form: 0,
                color: 0,
                movement: 0,
                speed: 0.0,
                angle: 0,
                material: 0,
                mesh: 0,
                visible: true
            }
        }
        var roundTask = {
            movement: 0,
            color: 0,
            form: 0
        }
        var roundTimerId = setInterval(roundTimer, 100);
        generateFigures(figures);
        console.log("Figure :", figureMovement[figures[0].movement], figureColors[figures[0].color], figureForms[
            figures[0].form], );
        for (var i = 0; i < numFigures; i++) scene.add(figures[i].mesh);
        //~ scene.remove(cube);
        rescaleTextInfo();
        generateTask();
        window.addEventListener('resize', onWindowResize, false);

        function roundTimer() {
            roundTime -= 1;
            var timerText = roundTime / 10;
            gameTimer.innerHTML = 'Time: ' + timerText.toFixed(1);
            if (roundTime <= 30) gameTimer.style.color = '#ff0000';
            else if (roundTime <= 60) gameTimer.style.color = '#ffff00';
            if (roundTime <= 0) {
                generateTask();
                currentRound++;
                if (currentRound <= 4) generateTask();
                else clearInterval(roundTimerId);
            }
        }

        function generateTask() {
            var currentFigure = taskSet[currentRound].figureNumber; //getRandomInt(0, numFigures - 1);
            roundTask.form = figures[currentFigure].form;
            roundTask.color = figures[currentFigure].color;
            roundTask.movement = figures[currentFigure].movement;
            roundTime = 100.0;
            gameTask.innerHTML = 'Find' + ' ' + figureMovement[roundTask.movement] + ' ' + figureColors[roundTask
                .color] + ' ' + figureForms[roundTask.form];
            //~ gameTimer.innerHTML = roundTime/10;
            gameTimer.style.color = '#00ff00';
            gameRoundInfo.innerHTML = 'Round: ' + (currentRound + 1) + '/5';
            gameScoreInfo.innerHTML = 'Score: ' + gameScore;
        }

        function onWindowResize() {
            renderer.setPixelRatio(window.devicePixelRatio);
            rendererSize.x = window.innerWidth;
            rendererSize.y = window.innerWidth / sceneSize.ratio;
            renderer.setSize(rendererSize.x, rendererSize.y);
            rescaleTextInfo();
        }
        //~ renderer.setClearColor(0x0f0f0f, 1);
        camera.position.z = 500;

        function render() {
            processFigures(figures);
            requestAnimationFrame(render);
            renderer.render(scene, camera);
        }
        render();

        function getMousePosition(event) {
            var sMouseX = ((event.pageX) / rendererSize.x - 0.5) * sceneSize.x;
            var sMouseY = -((event.pageY - 100) / rendererSize.y - 0.5) * sceneSize.y;
            //~ console.log('Mouse: ' + sMouseX + ' : ' + sMouseY);
            for (var i = 0; i < numFigures; i++) {
                if (figures[i].visible && sMouseX >= (figures[i].x - 80) && sMouseX <= (figures[i].x + 80) && sMouseY >=
                    (figures[i].y - 80) && sMouseY <= (figures[i].y + 80)) {
                    if (roundTask.form == figures[i].form && roundTask.color == figures[i].color && roundTask
                        .movement == figures[i].movement) taskSet[currentRound].complete = true;
                    //~ scene.remove(figures[i].mesh);
                    //~ console.log(figureMovement[figures[i].movement] + ' ' +figureColors[figures[i].color] + ' ' + figureForms[figures[i].form]);
                    if (currentRound < 4) {
                        currentRound++;
                        generateTask();
                    } else stopGame();
                    //~ figures[i].visible = false;
                    //~ console.log('Clicked on ' + i + ' figure');
                }
            }
        }

        function stopGame() {
            clearInterval(roundTimerId);
            document.removeEventListener('click', getMousePosition);
            var temp;
            for (var i = 0; i < numFigures; i++) {
                temp = false;
                for (var j = 0; j < 5; j++)
                    if (taskSet[j].figureNumber == i) temp = true;
                if (!temp) scene.remove(figures[i].mesh);
            }
            for (var i = 0; i < 5; i++)
                if (taskSet[i].complete) gameScore += 100;
            gameScoreInfo.innerHTML = 'Score: ' + gameScore;
        }

        function rescaleTextInfo() {
            gameTask.style.width = window.innerWidth;
            gameTask.style.height = 50;
            gameTask.style.fontSize = 50 + 'px';
            //~ gameTask.innerHTML = 'Find' + ' ' + figureMovement[figures[0].movement] + ' ' + figureColors[figures[0].color] + ' ' + figureForms[figures[0].form];
            gameTask.style.top = 125 + rendererSize.y + 'px'; //window.innerHeight - 100 + 'px';//800 + 'px';
            gameTask.style.left = 0 + 'px';
            gameTimer.style.width = window.innerWidth;
            gameTimer.style.height = 50;
            gameTimer.style.fontSize = 50 + 'px';
            gameTimer.style.top = 25 + 'px'; //800 + 'px';
            gameTimer.style.left = 0 + 'px';
            gameRoundInfo.style.width = window.innerWidth;
            gameRoundInfo.style.height = 50;
            gameRoundInfo.style.fontSize = 50 + 'px';
            gameRoundInfo.style.top = 25 + 'px'; //800 + 'px';
            gameRoundInfo.style.left = 0 + 'px';
            gameScoreInfo.style.width = window.innerWidth;
            gameScoreInfo.style.height = 50;
            gameScoreInfo.style.fontSize = 50 + 'px';
            gameScoreInfo.style.top = 25 + 'px'; //800 + 'px';
            gameScoreInfo.style.left = 0 + 'px';
        }

        function generateTaskSet() {
            var completeTaskArray = [];
            var currentTask;
            for (var i = 0; i < numFigures; i++) completeTaskArray.push(i);
            for (var i = 0; i < 5; i++) {
                currentTask = getRandomInt(0, numFigures - i - 1);
                //~ console.log(currentTask);
                //~ console.log(completeTaskArray);
                taskSet[i] = {
                    figureNumber: completeTaskArray[currentTask],
                    complete: false
                };
                completeTaskArray.splice(currentTask, 1);
            }
            console.log(taskSet);
            //~ for(var i = 0; i < 5; i++) console.log('task ' + taskSet[i].figureNumber);
        }

        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function getRandomFloat(min, max) {
            return Math.random() * (max - min) + min;
        }

        function generateFigures(obj) {
            var yCord, xCord1, xCord2;
            var completeFiguresArray = [];
            var ramdomFigure;
            for (var i = 0; i < figureForms.length; i++) {
                for (var j = 0; j < figureColors.length; j++) {
                    for (var k = 0; k < figureMovement.length; k++) {
                        if (!(i == 1 && k == 3)) completeFiguresArray.push({
                            f: i,
                            c: j,
                            m: k
                        });
                    }
                }
            }
            if (numFigures <= 12) {
                xCord1 = 75 - (numFigures * 150 / 2);
                yCord = 0;
            } else {
                xCord1 = 75 - (12 * 150 / 2);
                xCord2 = 75 - ((numFigures - 12) * 150 / 2);
                yCord = 175;
            }
            for (var i = 0; i < numFigures; i++) {
                if (i > 11) yCord = -175;
                obj[i].x = xCord1;
                randomFigure = getRandomInt(0, completeFiguresArray.length - 1);
                obj[i].form = completeFiguresArray[randomFigure].f;
                obj[i].color = completeFiguresArray[randomFigure].c;
                obj[i].movement = completeFiguresArray[randomFigure].m;
                completeFiguresArray.splice(randomFigure, 1);
                switch (obj[i].form) {
                    case 0:
                        obj[i].mesh = new THREE.Mesh(squareGeometry, matherials[obj[i].color]);
                        break;
                    case 1:
                        obj[i].mesh = new THREE.Mesh(circleGeometry, matherials[obj[i].color]);
                        break;
                    case 2:
                        obj[i].mesh = new THREE.Mesh(triangleGeometry, matherials[obj[i].color]);
                        obj[i].mesh.rotation.z = -Math.PI / 6;
                        break;
                    case 3:
                        obj[i].mesh = new THREE.Mesh(rhombusGeometry, matherials[obj[i].color]);
                        break;
                }
                switch (obj[i].movement) {
                    case 0:
                        obj[i].y = yCord;
                        break;
                    case 1:
                        obj[i].y = getRandomInt(yCord, yCord + 100);
                        obj[i].speed = -1;
                        break;
                    case 2:
                        obj[i].y = yCord + 100;
                        obj[i].angle = getRandomFloat(0, Math.PI);
                        break;
                    case 3:
                        obj[i].y = yCord;
                        obj[i].speed = (getRandomInt(0, 1) ? 1 : -1) * getRandomFloat(0.2, 1.0);
                        break;
                }
                obj[i].mesh.position.x = obj[i].x;
                obj[i].mesh.position.y = obj[i].y;
                xCord1 += 150;
                if (xCord1 >= 960) xCord1 = xCord2;
            }
        }

        function processFigures(obj) {
            var yCord;
            if (numFigures <= 12) yCord = 0;
            else yCord = 175;
            for (var i = 0; i < numFigures; i++) {
                if (i > 11) yCord = -175;
                switch (obj[i].movement) {
                    case 0:
                        break;
                    case 1:
                        obj[i].y += obj[i].speed;
                        //~ obj[i].y = Math.floor(obj[i].y);
                        obj[i].speed -= 0.5;
                        if (obj[i].y < (yCord - 100)) {
                            obj[i].speed = -(obj[i].speed + 0.5);
                        }
                        obj[i].mesh.position.y = obj[i].y;
                        break;
                    case 2:
                        obj[i].y = yCord + 100 + Math.sin(obj[i].angle) * 10;
                        obj[i].angle += 0.1;
                        obj[i].mesh.position.y = obj[i].y;
                        break;
                    case 3:
                        obj[i].mesh.rotation.z += 0.05 * obj[i].speed;
                        break;
                }
            }
        }
    </script>
</body>

</html>